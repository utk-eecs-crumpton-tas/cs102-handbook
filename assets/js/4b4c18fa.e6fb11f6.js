"use strict";(self.webpackChunkcs102_handbook=self.webpackChunkcs102_handbook||[]).push([[4826],{7937:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var i=t(5893),r=t(1151);const a={},s="Multi-User Dungeons (MUD) Notes",o={id:"in-class-lab-notes/mud-notes",title:"Multi-User Dungeons (MUD) Notes",description:"Here is a graph of what the rooms look like",source:"@site/docs/in-class-lab-notes/mud-notes.md",sourceDirName:"in-class-lab-notes",slug:"/in-class-lab-notes/mud-notes",permalink:"/cs102-handbook/docs/in-class-lab-notes/mud-notes",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"Sidebar",previous:{title:"Bowling Notes",permalink:"/cs102-handbook/docs/in-class-lab-notes/bowling-notes"},next:{title:"Sorting Algorithms Notes",permalink:"/cs102-handbook/docs/in-class-lab-notes/sorting-algorithms"}},l={},c=[{value:"File Format",id:"file-format",level:2},{value:"Resetting a File Stream",id:"resetting-a-file-stream",level:2},{value:"Sentinel Values",id:"sentinel-values",level:2},{value:"<code>new</code> and <code>delete</code> operators",id:"new-and-delete-operators",level:2},{value:"Stack vs. Heap",id:"stack-vs-heap",level:3},{value:"Using <code>new</code> and <code>delete</code>",id:"using-new-and-delete",level:3},{value:"Initializing Data on the Heap",id:"initializing-data-on-the-heap",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"multi-user-dungeons-mud-notes",children:"Multi-User Dungeons (MUD) Notes"}),"\n",(0,i.jsx)(n.p,{children:"Here is a graph of what the rooms look like"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"room1-diagram",src:t(1771).Z+"",width:"322",height:"320"})}),"\n",(0,i.jsx)(n.h2,{id:"file-format",children:"File Format"}),"\n",(0,i.jsx)(n.p,{children:"Example Room"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-txt",children:"Room #0\n~\nYou are at the start. Your journey begins..\n~\ns 5\n~\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Each room will have 3 fields, they are each delimited by tildes. ",(0,i.jsx)(n.code,{children:"getline"})," will be helpful here for counting the number of rooms in the file."]}),"\n",(0,i.jsx)(n.h2,{id:"resetting-a-file-stream",children:"Resetting a File Stream"}),"\n",(0,i.jsx)(n.p,{children:"This lab requires us to read a file multiple times: once to count the number of rooms in the file and allocate enough memory for them, and then again to read the rooms into memory. It is possible to close and reopen the file, but there is a more efficient way."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"file.clear(); // reset the error state\nfile.seekg(0); // move the cursor back to the beginning of the file\n"})}),"\n",(0,i.jsx)(n.p,{children:"We have gone over clear before. Basically, when an input stream exhausts its input, it will enter an error state. While in the error state it will ignore any commands we try to give it. We can reset the error state by calling clear."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"file.seekg(0);"})," is new. This will set the position of the next character to be read to the beginning of the file. We can essentially reread the file from the beginning like we just opened it."]}),"\n",(0,i.jsxs)(n.p,{children:["For future reference, ",(0,i.jsx)(n.code,{children:"seekg"})," can be used to navigating to an arbitrary position in the file, but we will not be using that functionality in this lab."]}),"\n",(0,i.jsx)(n.h2,{id:"sentinel-values",children:"Sentinel Values"}),"\n",(0,i.jsx)(n.p,{children:"A sentinel value is an arbitrarily significant value used to encode a special condition, usually to indicate the end of a sequence of values, or a non-existent state aka null. In this lab, we will use sentinel values to indicate that a room does not have a connection in a particular direction."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Room {\n  int north = -1; // sentinel value, -1 means no room\n  int south = -1;\n  int east = -1;\n  int west = -1;\n};\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"new-and-delete-operators",children:[(0,i.jsx)(n.code,{children:"new"})," and ",(0,i.jsx)(n.code,{children:"delete"})," operators"]}),"\n",(0,i.jsx)(n.h3,{id:"stack-vs-heap",children:"Stack vs. Heap"}),"\n",(0,i.jsxs)(n.p,{children:["We can use the ",(0,i.jsx)(n.code,{children:"new"})," operator to allocate memory on the heap. The heap is a lot more flexible than the stack, but less efficient. All the data structures we have been using from the stl like vectors, use the heap under the hood. This is what allows us to have dynamic data structures that can grow and shrink as needed e.g. ",(0,i.jsx)(n.code,{children:"push_back"})," and ",(0,i.jsx)(n.code,{children:"pop_back"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When would we use ",(0,i.jsx)(n.code,{children:"new"})," and ",(0,i.jsx)(n.code,{children:"delete"}),"? Here is an example of the limitations of the stack:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void do_something_else(){\n    /* ... */\n}\nint *create_array_on_stack(const size_t array_size) {\n  int array[array_size];\n  for (size_t i = 0; i < array_size; ++i) {\n    array[i] = i;\n  }\n  return array;\n}\n\nint main() {\n  const size_t array_size = 10;\n  int *array_ptr = create_array_on_stack(array_size);\n  array_ptr[0]; // this will work -- returns 0\n  array_ptr[1]; // this will work -- returns 1\n  do_something_else();\n  array_ptr[0]; // uh oh, this will not work -- returns garbage\n  array_ptr[1]; // uh oh, this will not work -- returns garbage\n\n  return 0;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Any memory allocated by a normal function, save for the return type, will immediately be overwritten by the next stack frame, or function call. This is where the heap comes in"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int *create_array_on_heap(int size) {\n  int *array = new int[size];\n  for (int i = 0; i < size; i++) {\n    array[i] = i;\n  }\n  return array;\n}\n\nint main() {\n  const size_t array_size = 10;\n  int *array_ptr = create_array_on_heap(array_size);\n  array_ptr[0]; // this will work -- returns 0\n  array_ptr[1]; // this will work -- returns 1\n  do_something_else();\n  array_ptr[0]; // this will work -- returns 0\n  array_ptr[1]; // this will work -- returns 1\n\n  delete[] array_ptr; // must delete heap memory manually!\n\n  return 0;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The caveat with the heap, is we must remember to delete the memory ourselves once we are finished with it. If not, we will have a memory leak, memory no longer in use but cannot be reclaimed by the operating system."}),"\n",(0,i.jsxs)(n.h3,{id:"using-new-and-delete",children:["Using ",(0,i.jsx)(n.code,{children:"new"})," and ",(0,i.jsx)(n.code,{children:"delete"})]}),"\n",(0,i.jsxs)(n.p,{children:["If you noticed, there are two ways to use the ",(0,i.jsx)(n.code,{children:"new"})," and ",(0,i.jsx)(n.code,{children:"delete"})," operators, with ",(0,i.jsx)(n.code,{children:"[]"})," and without ",(0,i.jsx)(n.code,{children:"[]"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int *single_int = new int;\nint *array_of_ints = new int[10];\n\ndelete single_int;\ndelete[] array_of_ints;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you call ",(0,i.jsx)(n.code,{children:"new"})," with ",(0,i.jsx)(n.code,{children:"[]"}),", you must call ",(0,i.jsx)(n.code,{children:"delete[]"})," with the same pointer. If you call ",(0,i.jsx)(n.code,{children:"new"})," without ",(0,i.jsx)(n.code,{children:"[]"}),", you must call ",(0,i.jsx)(n.code,{children:"delete"})," with the same pointer. If you do not, you will get a memory error."]}),"\n",(0,i.jsx)(n.h3,{id:"initializing-data-on-the-heap",children:"Initializing Data on the Heap"}),"\n",(0,i.jsxs)(n.p,{children:["You should not need this for this lab, but a final note about ",(0,i.jsx)(n.code,{children:"new"})," and ",(0,i.jsx)(n.code,{children:"delete"}),", you can use any constructor you want with ",(0,i.jsx)(n.code,{children:"new"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// stack construction -- these should be familiar\nvector<int> ints(10, 0);\nvector<int> ints{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n// heap construction -- exact same syntax as stack construction, just returns a pointer\nvector<int> *ints_ptr = new vector<int>(10, 0);\nvector<int> *ints_ptr = new vector<int>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n// primitive types also have constructors in c++\nint *value = new int(1);\nint *values = new int[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It is also worth noting that in ",(0,i.jsx)(n.code,{children:"c++"})," memory initialized with ",(0,i.jsx)(n.code,{children:"new"})," is initialized to 0 by default whereas on the stack it is not."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1771:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/mud-2ad4c7a770828022a5f409de2bd0dd62.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>s});var i=t(7294);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkcs102_handbook=self.webpackChunkcs102_handbook||[]).push([[486],{2710:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=s(5893),t=s(1151);const r={},l="Bitset Notes",a={id:"in-class-lab-notes/bitset-notes",title:"Bitset Notes",description:"Making Binary Numbers in C++",source:"@site/docs/in-class-lab-notes/bitset-notes.md",sourceDirName:"in-class-lab-notes",slug:"/in-class-lab-notes/bitset-notes",permalink:"/cs102-handbook/docs/in-class-lab-notes/bitset-notes",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"Sidebar",previous:{title:"In-Class Lab Notes",permalink:"/cs102-handbook/docs/category/in-class-lab-notes"},next:{title:"Boiling Water Notes",permalink:"/cs102-handbook/docs/in-class-lab-notes/boiling-water-notes"}},o={},c=[{value:"Making Binary Numbers in C++",id:"making-binary-numbers-in-c",level:2},{value:"Converting a 1D Index into a 2D Index",id:"converting-a-1d-index-into-a-2d-index",level:2},{value:"Bitwise Operations",id:"bitwise-operations",level:2},{value:"Operator precedence",id:"operator-precedence",level:3},{value:"Right and Left Shift Examples",id:"right-and-left-shift-examples",level:2},{value:"Shorthand syntax",id:"shorthand-syntax",level:3},{value:"Returning a Boolean from a Function",id:"returning-a-boolean-from-a-function",level:2},{value:"Bitset Calculators",id:"bitset-calculators",level:2},{value:"vector APIs you will need for this lab",id:"vector-apis-you-will-need-for-this-lab",level:2},{value:"<code>resize(new_size, fill_value)</code>",id:"resizenew_size-fill_value",level:3},{value:"<code>pop_back()</code>",id:"pop_back",level:3},{value:"<code>back()</code>",id:"back",level:3},{value:"ToBinary Spacing",id:"tobinary-spacing",level:2},{value:"Helpful Resources",id:"helpful-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"bitset-notes",children:"Bitset Notes"}),"\n",(0,i.jsx)(n.h2,{id:"making-binary-numbers-in-c",children:"Making Binary Numbers in C++"}),"\n",(0,i.jsx)(n.p,{children:"Not needed for this lab, but good to know!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  const int binary_9 = 0b1001;\n  const int binary_145 = 0b10010001;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"converting-a-1d-index-into-a-2d-index",children:"Converting a 1D Index into a 2D Index"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  const size_t ARRAY_SIZE = 26;\n  const size_t ROW_SIZE = 6;\n\n  int array_2d[4][6] = {\n      {0, 1, 2, 3, 4, 5},\n      {6, 7, 8, 9, 10, 11},\n      {12, 13, 14, 15, 16, 17},\n      {18, 19, 20, 21, 22, 13},\n  };\n\n  for (size_t i = 0; i < ARRAY_SIZE; ++i) {\n    // i = 0, row = 0, column = 0\n    // i = 1, row = 0, column = 1\n    // ...\n    // i = 6, row = 1, column = 0\n    // i = 7, row = 1, column = 1\n    const size_t row_index = i / ROW_SIZE;\n    const size_t column_index = i % ROW_SIZE;\n    const int value = array_2d[row_index][column_index];\n    std::cout << value << std::endl;\n  }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Your row size in this case will be 32, the number of bits in an ",(0,i.jsx)(n.code,{children:"int"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"bitwise-operations",children:"Bitwise Operations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"~"})," bitwise NOT"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<<"})," left shift"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:">>"})," right shift"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"&"})," bitwise AND"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"|"})," bitwise OR"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"^"})," bitwise XOR"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For this lab, you will not use xor!!"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/lab-walkthroughs/bitset#bitwise-operators",children:"Ethan's overview of bitwise operators"})}),"\n",(0,i.jsx)(n.h3,{id:"operator-precedence",children:"Operator precedence"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"~"})," has the highest precedence meaning it will be evaluated first"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<<"})," and ",(0,i.jsx)(n.code,{children:">>"})," have the second highest precedence. Since left-shift and right-shift, raise to a power of 2 or divide by a power of 2, I tend to think of them as bitwise multiplication and bitwise division."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"&"}),", ",(0,i.jsx)(n.code,{children:"|"}),", ",(0,i.jsx)(n.code,{children:"^"})," have the lowest precedence."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["WARNING: the ",(0,i.jsx)(n.code,{children:"=="})," operator has higher precedence than ",(0,i.jsx)(n.code,{children:"&"}),", ",(0,i.jsx)(n.code,{children:"|"}),", ",(0,i.jsx)(n.code,{children:"^"}),". This means that ",(0,i.jsx)(n.code,{children:"bitset & mask != 0"})," would be evaluated as ",(0,i.jsx)(n.code,{children:"bitset & (mask != 0)"})," when we want ",(0,i.jsx)(n.code,{children:"(bitset & mask) != 0"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"right-and-left-shift-examples",children:"Right and Left Shift Examples"}),"\n",(0,i.jsx)(n.p,{children:"Right shifting and left shifting are the same as multiplying and dividing by a power of 2."}),"\n",(0,i.jsxs)(n.p,{children:["NOTE: do not use the ",(0,i.jsx)(n.code,{children:"pow"})," function from ",(0,i.jsx)(n.code,{children:"cmath"})," for this lab!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  int x = 64 << 1; // same as 64 * pow(2, 1) or 64 * 2\n  int x = 64 << 3; // same as 64 * pow(2, 3) or 64 * 8\n  int x = 64 >> 1; // same as 64 / pow(2, 1) or 64 / 2\n  int x = 64 >> 3; // same as 64 / pow(2, 3) or 64 / 8\n"})}),"\n",(0,i.jsx)(n.h3,{id:"shorthand-syntax",children:"Shorthand syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Like all other operators in ",(0,i.jsx)(n.code,{children:"c++"}),", you can use the shorthand assignment syntax with any bit operator"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  int bitset = 0b1001;\n  bitset |= 0b1000; // bitset = bitset | 0b1000\n  bitset &= 0b1000; // bitset = bitset & 0b1000\n  bitset ^= 0b1000; // bitset = bitset ^ 0b1000\n  bitset <<= 1;     // bitset = bitset << 1\n"})}),"\n",(0,i.jsx)(n.h2,{id:"returning-a-boolean-from-a-function",children:"Returning a Boolean from a Function"}),"\n",(0,i.jsx)(n.p,{children:"The test function returns a boolean value, whether the bit is set or not."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"bool BITSET::Test(const int index) const\n"})}),"\n",(0,i.jsx)(n.p,{children:"Do not do"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"bool BITSET::Test(const int index) const {\n    if ((bitset & mask) != 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"bool BITSET::Test(const int index) const {\n    if ((bitset & mask) == 0) {\n        return false;\n    } else {\n        return true;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Do"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"bool BITSET::Test(const int index) const {\n    return (bitset & mask) != 0;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or possibly a more intuitive way"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"bool BITSET::Test(const int index) const {\n    const int test_bit = bitset & mask;\n    return test_bit != 0;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"bitset-calculators",children:"Bitset Calculators"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/lab-walkthroughs/bitset#examples",children:"Ethan's examples of bitwise calculators"})}),"\n",(0,i.jsx)(n.h2,{id:"vector-apis-you-will-need-for-this-lab",children:"vector APIs you will need for this lab"}),"\n",(0,i.jsx)(n.h3,{id:"resizenew_size-fill_value",children:(0,i.jsx)(n.code,{children:"resize(new_size, fill_value)"})}),"\n",(0,i.jsx)(n.p,{children:"You will need this for the set function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  std::vector<int> data{1, 2, 3, 4, 5};\n  data.resize(10 /* new size */, 0 /* fill value */); // resize to 10 elements, fill with 0\n  // after: {1, 2, 3, 4, 5, 0, 0, 0, 0, 0}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Same call signature as the ",(0,i.jsx)(n.code,{children:"vector"})," constructor"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"std::vector<int> data(10 /* new size */, 0 /* fill value */);\ndata; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} 10 0s\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pop_back",children:(0,i.jsx)(n.code,{children:"pop_back()"})}),"\n",(0,i.jsx)(n.p,{children:"You will need this for the clear function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  std::vector<int> data{1, 2, 3, 4, 5};\n  data.pop_back(); // remove last element\n  // after: {1, 2, 3, 4}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"back",children:(0,i.jsx)(n.code,{children:"back()"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the last element in a vector. Not needed, but helpful for the clear function when checking if the last element is 0."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  std::vector<int> data{1, 2, 3, 4, 5};\n  data.back(); // returns 5\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tobinary-spacing",children:"ToBinary Spacing"}),"\n",(0,i.jsx)(n.p,{children:"When 32 (the number of bits) is not evenly divisible by the size of the spacing, the smallest group of bits will go on the right. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'ToBinary(0b1001, 3); // returns "000 000 000 000 000 000 000 000 000 010 01"\nToBinary(0b1001, 5); // returns "00000 00000 00000 00000 00000 00010 01"\nToBinary(0b1001, 6); // returns "000000 000000 000000 000000 000010 01"\n'})}),"\n",(0,i.jsx)(n.p,{children:"A common error, make sure you are not adding an extra space at the end of the string!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'ToBinary(0b1001, 3); // Does not return "000 000 000 000 000 000 000 000 000 010 01 "\nToBinary(0b1001, 5); // Does not return "00000 00000 00000 00000 00000 00010 01 "\nToBinary(0b1001, 6); // Does not return "000000 000000 000000 000000 000010 01 "\n'})}),"\n",(0,i.jsx)(n.h2,{id:"helpful-resources",children:"Helpful Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/lab-walkthroughs/bitset",children:"Ethan's walkthrough of the whole lab"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Make sure to set up the tests first thing. These are the tests we will grade the lab with!"})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>l});var i=s(7294);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);
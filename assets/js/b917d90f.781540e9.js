"use strict";(self.webpackChunkcs102_handbook=self.webpackChunkcs102_handbook||[]).push([[775],{4527:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>h});var t=n(5893),s=n(1151);const l={},o="PPM Manipulation",r={id:"lab-walkthroughs/ppm-manipulator",title:"PPM Manipulation",description:"Manipulate images in the PPM format from the command line.",source:"@site/docs/lab-walkthroughs/ppm-manipulator.md",sourceDirName:"lab-walkthroughs",slug:"/lab-walkthroughs/ppm-manipulator",permalink:"/cs102-handbook/docs/lab-walkthroughs/ppm-manipulator",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"Sidebar",previous:{title:"Calculator",permalink:"/cs102-handbook/docs/lab-walkthroughs/calculator"},next:{title:"Speeding Ticket Calculator",permalink:"/cs102-handbook/docs/lab-walkthroughs/speeding-ticket-calculator"}},d={},h=[{value:"Introduction",id:"introduction",level:2},{value:"What is PPM?",id:"what-is-ppm",level:2},{value:"What it contains",id:"what-it-contains",level:3},{value:"Pixel",id:"pixel",level:2},{value:"Picture",id:"picture",level:2},{value:"Width, height, and max intensity",id:"width-height-and-max-intensity",level:3},{value:"Pixel list",id:"pixel-list",level:3},{value:"Constructor",id:"constructor",level:3},{value:"Get Pixel (Immutable)",id:"get-pixel-immutable",level:3},{value:"Get Pixel (Mutable)",id:"get-pixel-mutable",level:3},{value:"Set Pixel",id:"set-pixel",level:3},{value:"Invert",id:"invert",level:3},{value:"Flip X",id:"flip-x",level:3},{value:"Flip Y",id:"flip-y",level:3},{value:"Read Input",id:"read-input",level:3},{value:"example",id:"example",level:4},{value:"Deciding which to use",id:"deciding-which-to-use",level:4},{value:"Reading",id:"reading",level:4}];function a(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"ppm-manipulation",children:"PPM Manipulation"}),"\n",(0,t.jsx)(i.p,{children:"Manipulate images in the PPM format from the command line."}),"\n",(0,t.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(i.p,{children:["This is definitely the hardest lab this semester, probably a bit harder than both blackjack, but it's also the most cool, in my opinion. The purpose of this lab is to be able to manipulate a ",(0,t.jsx)(i.code,{children:".ppm"})," file in several ways. It'll familiarize you more with classes, and also maybe make you think a bit."]}),"\n",(0,t.jsx)(i.h2,{id:"what-is-ppm",children:"What is PPM?"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"PPM"})," is a file type that designates a specific format the file should adhere to. Just like how your ",(0,t.jsx)(i.code,{children:".cpp"})," files need to include things like ",(0,t.jsx)(i.code,{children:"int main()"})," or ",(0,t.jsx)(i.code,{children:"#include"}),", a .",(0,t.jsx)(i.code,{children:"ppm"}),' file needs to include "meta" content that outlines details pertaining to the content, and of course, it also needs to contain the content itself (e.g. the "pixels" that make up the image).']}),"\n",(0,t.jsx)(i.h3,{id:"what-it-contains",children:"What it contains"}),"\n",(0,t.jsxs)(i.p,{children:["If you were to open a ",(0,t.jsx)(i.code,{children:".ppm"})," file with a text editor, this is what you would see (this is on a per-line basis, in this exact order)"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["A heading which will always be the string ",(0,t.jsx)(i.code,{children:"P3"}),". If a ",(0,t.jsx)(i.code,{children:".ppm"})," file does not contain this, then it does not conform to the standard that a ",(0,t.jsx)(i.code,{children:".ppm"})," file should, and therefore should be omitted."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"width"})," and ",(0,t.jsx)(i.code,{children:"height"})," (WxH) of the image in pixels (e.g. ",(0,t.jsx)(i.code,{children:"150 150"})," would be 150x150 image)"]}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"Max Intensity"}),". i.e. the absolute range of any color value in the image. Typically this will be ",(0,t.jsx)(i.code,{children:"[0, 255]"}),", but the max intensity determines the bound, so assume the color range is ",(0,t.jsx)(i.code,{children:"[0, maxIntensity]"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["Every line after this describes the color value of each subsequent pixel. Represented by integers ranging from the color range mentioned earlier. ",(0,t.jsx)(i.strong,{children:"One important thing to note"})," is that these lines could be in various formats. They can follow/precede commented lines (refer to #5), they can be in the format ",(0,t.jsx)(i.code,{children:"r g b"})," or they can be in the format ",(0,t.jsx)(i.code,{children:"r\\nb\\ng\\n"})," (i.e. on separate lines), basically their format will be inconsistent, BUT we can work with that."]}),"\n",(0,t.jsxs)(i.li,{children:["Any line beginning with ",(0,t.jsx)(i.code,{children:"#"})," should be skipped, as it simply denotes a comment."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Here's an example of a ",(0,t.jsx)(i.code,{children:".ppm"})," file in plain text"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-P3",children:"3 2\n255\n255 0 0\n0 255 0\n0 0 255\n255 255 0\n255 255 255\n0 0 0\n"})}),"\n",(0,t.jsxs)(i.p,{children:["As you can see, it is a valid ",(0,t.jsx)(i.code,{children:".ppm"})," file as it conforms to the format required."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["It has a header of ",(0,t.jsx)(i.code,{children:"P3"})]}),"\n",(0,t.jsxs)(i.li,{children:["It has a width of ",(0,t.jsx)(i.code,{children:"3px"})," and a height of ",(0,t.jsx)(i.code,{children:"2px"})]}),"\n",(0,t.jsxs)(i.li,{children:["The max intensity is ",(0,t.jsx)(i.code,{children:"255"})]}),"\n",(0,t.jsxs)(i.li,{children:["The dimensions of the image are ",(0,t.jsx)(i.code,{children:"3x2"})]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["We know the dimensions of the file are ",(0,t.jsx)(i.code,{children:"3x2"}),", so logically there are 6 pixels in total in the image. Every line after the max intensity is the color value of a pixel at that index (going from left to right, and then moving to the next row once you've reached the last column). Because there are ",(0,t.jsx)(i.code,{children:"3 RGB"})," values per pixel, and there are ",(0,t.jsx)(i.code,{children:"6 pixels"}),", we should expect to read ",(0,t.jsx)(i.code,{children:"18 RGB values"}),". This is exactly what we see in the file."]}),"\n",(0,t.jsx)(i.h1,{id:"your-job",children:"Your Job"}),"\n",(0,t.jsxs)(i.p,{children:["Your job for this lab is to be able to parse these ",(0,t.jsx)(i.code,{children:".ppm"})," files and modify them in some way. Namely, your program should be able to do the following things:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Read a ",(0,t.jsx)(i.code,{children:".ppm"})," file. e.g. check for ",(0,t.jsx)(i.code,{children:"P3"}),", store your width/height/max intens, and store the color values of each pixel."]}),"\n",(0,t.jsxs)(i.li,{children:["Write a ",(0,t.jsx)(i.code,{children:".ppm"})," file"]}),"\n",(0,t.jsx)(i.li,{children:"Flip an image on the x-axis"}),"\n",(0,t.jsx)(i.li,{children:"Flip an image on the y-axis"}),"\n",(0,t.jsx)(i.li,{children:"Invert an image"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"pixel",children:"Pixel"}),"\n",(0,t.jsxs)(i.p,{children:["The first thing you'll want to get out of the way is your ",(0,t.jsx)(i.code,{children:"Pixel"})," structure. This will make it easy to read/write data with pixels. Using the ",(0,t.jsx)(i.code,{children:"Pixel"})," structure, we'll create a ",(0,t.jsx)(i.code,{children:"Picture"})," class whose core data member will be a ",(0,t.jsx)(i.code,{children:"vector"})," of ",(0,t.jsx)(i.code,{children:"Pixel"}),"s."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"struct Pixel"})," contains:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["3 ",(0,t.jsx)(i.code,{children:"unsigned int"}),"s, one for each ",(0,t.jsx)(i.code,{children:"r"}),", ",(0,t.jsx)(i.code,{children:"g"}),", and ",(0,t.jsx)(i.code,{children:"b"}),". The reason we're using ",(0,t.jsx)(i.code,{children:"unsigned"})," is because our color range is ",(0,t.jsx)(i.code,{children:"[0,max_intensity]"}),", which is positive only range."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This should be pretty easy to create yourself."}),"\n",(0,t.jsx)(i.h2,{id:"picture",children:"Picture"}),"\n",(0,t.jsx)(i.p,{children:"This is the greater class that will represent the PPM image itself and will contain the data members that will be used to manipulate the image."}),"\n",(0,t.jsx)(i.h3,{id:"width-height-and-max-intensity",children:"Width, height, and max intensity"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"private int"})," - width of the picture"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"private int"})," - height of the picture"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"private int"})," - max intensity of the picture"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"pixel-list",children:"Pixel list"}),"\n",(0,t.jsxs)(i.p,{children:["A ",(0,t.jsx)(i.em,{children:"private"})," ",(0,t.jsx)(i.code,{children:"vector"})," of ",(0,t.jsx)(i.code,{children:"Pixel"}),'s. These will be our "coordinates" so to speak.']}),"\n",(0,t.jsx)(i.h3,{id:"constructor",children:"Constructor"}),"\n",(0,t.jsxs)(i.p,{children:["A public constructor that sets up our class instance. It takes 0 arguments and sets the width, height, and max intensity to 0. So once you've invoked thsi constructor, you'll have a ",(0,t.jsx)(i.code,{children:"Picture"})," object that has no pixels, an image width of 0, an image height of 0, and a max intensity of 0."]}),"\n",(0,t.jsx)(i.h3,{id:"get-pixel-immutable",children:"Get Pixel (Immutable)"}),"\n",(0,t.jsxs)(i.p,{children:["A public method that returns a ",(0,t.jsx)(i.strong,{children:"read-only"})," (",(0,t.jsx)(i.code,{children:"const <TYPE>&"}),") Pixel object located at the row & col passed as arguments. You'll need to do some arithmetic to transpose the ",(0,t.jsx)(i.code,{children:"(row, col)"})," to a valid index to your vector of pixels since the vector is 1-dimensional. The formula for this is pretty simple, and you can easily google to find it online if you're not sure."]}),"\n",(0,t.jsx)(i.h3,{id:"get-pixel-mutable",children:"Get Pixel (Mutable)"}),"\n",(0,t.jsxs)(i.p,{children:["A public method that returns a ",(0,t.jsx)(i.strong,{children:"mutable"})," ",(0,t.jsx)(i.code,{children:"Pixel"})," object based on the row and column passed as arguments. You'll notice this is an ",(0,t.jsx)(i.em,{children:"overloaded"})," method since there is another method with a similar signature. The difference between the two is the return value. This method returns ",(0,t.jsx)(i.code,{children:"Pixel&"}),", whereas the other returns ",(0,t.jsx)(i.code,{children:"const Pixel&"}),". i.e. the return value of this method is mutable, meaning it can be modified. So if you wanted to, you could do something like this:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-cpp",children:"Picture pic;\nPixel p = pic.get_pixel(0,0);\np.r = 255;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["This would set the ",(0,t.jsx)(i.code,{children:"r"})," value of the pixel at ",(0,t.jsx)(i.code,{children:"(0,0)"})," to ",(0,t.jsx)(i.code,{children:"255"}),". This is useful when you want to modify the pixel at a specific location."]}),"\n",(0,t.jsxs)(i.p,{children:["This isn't possible if you call the other method, since it returns a ",(0,t.jsx)(i.code,{children:"const Pixel&"}),", which again means you can't modify the pixel."]}),"\n",(0,t.jsx)(i.p,{children:"The implementation of these methods is identical, only the return value type is different."}),"\n",(0,t.jsx)(i.h3,{id:"set-pixel",children:"Set Pixel"}),"\n",(0,t.jsxs)(i.p,{children:["A public method that sets a pixel at index ",(0,t.jsx)(i.code,{children:"(row, col)"})," (1D transposed) using the provided ",(0,t.jsx)(i.code,{children:"px"})," argument. (e.g. ",(0,t.jsx)(i.code,{children:"pixels[index] = px"}),"). In other words, it finds the index of the pixel in your vector, and changes it to the new one provided."]}),"\n",(0,t.jsx)(i.h3,{id:"invert",children:"Invert"}),"\n",(0,t.jsxs)(i.p,{children:["Inverts all pixels i.e. set every pixel color equal to ",(0,t.jsx)(i.code,{children:"max_intensity - r/g/b"}),", respectively. ",(0,t.jsx)(i.strong,{children:"This should update the vector of pixels"}),". Simply loop through your vector of ",(0,t.jsx)(i.code,{children:"Pixel"}),"s and update the color values accordingly."]}),"\n",(0,t.jsx)(i.h3,{id:"flip-x",children:"Flip X"}),"\n",(0,t.jsx)(i.p,{children:"Flips all pixels around the x-axis. The general idea here is to examine two rows simultaneously. So we look at every pixel in the top row and swap each pixel with the corresponding pixel in the bottom row, and then we jump to the next set of rows after we've finished one."}),"\n",(0,t.jsx)(i.p,{children:"You'll need two nested loops to do this. The outer loop will iterate over the rows, and the inner loop will iterate over the columns. You'll need to do some arithmetic to figure out which pixels to swap, but it's not too hard."}),"\n",(0,t.jsx)(i.h3,{id:"flip-y",children:"Flip Y"}),"\n",(0,t.jsxs)(i.p,{children:["This will be almost exactly like your ",(0,t.jsx)(i.code,{children:"flip_x()"})," method, except you'll swap the roles of your nested loops, and you'll replace the concept of top/bottom with left/right. This should be easy enough to do if you've already done ",(0,t.jsx)(i.code,{children:"flip_x()"}),", so I will leave it at this."]}),"\n",(0,t.jsx)(i.h3,{id:"read-input",children:"Read Input"}),"\n",(0,t.jsxs)(i.p,{children:["This part isn't hard, but a lot of students seem to be confused about what is going on with ",(0,t.jsx)(i.code,{children:"read_input()"})," here, so I will try to explain it to the best of my ability. All this method does is read the input of ",(0,t.jsx)(i.strong,{children:"either"})]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["a ",(0,t.jsx)(i.code,{children:".ppm"})," ",(0,t.jsx)(i.em,{children:"file"})]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"OR"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Standard input, e.g. ",(0,t.jsx)(i.code,{children:"stdin"}),", e.g. your keyboard -- like we've done most of the semester."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["The tricky part is that it can read either of those. We determine which of those we are reading from in ",(0,t.jsx)(i.code,{children:"main"})," from the arguments passed through ",(0,t.jsx)(i.code,{children:"argv[]"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"read_input()"})," method itself will have no difference in implementation whether or not we are reading from a file or from ",(0,t.jsx)(i.code,{children:"stdin"}),". This is because the argument it takes is of type ",(0,t.jsx)(i.code,{children:"istream"}),", which is any general-purpose input stream. Both ",(0,t.jsx)(i.code,{children:"ifstream"}),", and ",(0,t.jsx)(i.code,{children:"cin"})," are derived from ",(0,t.jsx)(i.code,{children:"istream"}),", so we can pass either of those into ",(0,t.jsx)(i.code,{children:"read_input()"})," and it will work. No matter what, we will be using the ",(0,t.jsx)(i.code,{children:"in"})," function argument to read once you're in the method from the following example"]}),"\n",(0,t.jsx)(i.h4,{id:"example",children:"example"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-cpp",children:'bool read_input(istream& in) {\n    in >> stuff; // this would be the same as cin >> stuff, or fin >> stuff\n}\n\nint main() {\n    // passing file input stream to read_input()\n    ifstream fin("file.txt");\n    read_input(fin);\n\n    // passing standard input stream to read input()\n    read_input(cin);\n}\n'})}),"\n",(0,t.jsx)(i.h4,{id:"deciding-which-to-use",children:"Deciding which to use"}),"\n",(0,t.jsxs)(i.p,{children:["In ",(0,t.jsx)(i.code,{children:"main"}),", we will be using ",(0,t.jsx)(i.code,{children:"argc"})," and ",(0,t.jsx)(i.code,{children:"argv"})," to determine whether or not we are reading from a file or from ",(0,t.jsx)(i.code,{children:"stdin"}),". Here is the argument format"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-bash",children:"./ppm <INPUT> <OUTPUT> <MANIPULATION>\n"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"INPUT"})," is the ",(0,t.jsx)(i.em,{children:"name"})," of the input file (e.g. ",(0,t.jsx)(i.code,{children:"file.ppm"}),"), ",(0,t.jsx)(i.strong,{children:"OR"})," it's a dash (",(0,t.jsx)(i.code,{children:"-"}),") if we are reading from ",(0,t.jsx)(i.code,{children:"stdin"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"OUTPUT"})," is the ",(0,t.jsx)(i.em,{children:"name"})," of the output file (e.g. ",(0,t.jsx)(i.code,{children:"file.ppm"}),"), ",(0,t.jsx)(i.strong,{children:"OR"})," it's a dash (",(0,t.jsx)(i.code,{children:"-"}),") if we are writing to ",(0,t.jsx)(i.code,{children:"stdout"})," (using ",(0,t.jsx)(i.code,{children:"cout"}),")."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"MANIPULATION"})," is the only optional argument and is the one-letter representation for the manipulation we want to do. This can be any of the following: It can be ",(0,t.jsx)(i.code,{children:"X"})," for ",(0,t.jsx)(i.code,{children:"flip_x"}),", ",(0,t.jsx)(i.code,{children:"Y"})," for ",(0,t.jsx)(i.code,{children:"flip_y"}),", or ",(0,t.jsx)(i.code,{children:"I"})," for ",(0,t.jsx)(i.code,{children:"invert"}),". If no argument is specified, then you won't modify the image at all."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"reading",children:"Reading"}),"\n",(0,t.jsx)(i.p,{children:"There are a ton of ways to do this. The meta content e.g. the header will always be in the same format, so you can read that fairly simply. Just like the last few labs, using a mixture of stringstream and getline is my recommendation, but there are other ways."})]})}function c(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},1151:(e,i,n)=>{n.d(i,{Z:()=>r,a:()=>o});var t=n(7294);const s={},l=t.createContext(s);function o(e){const i=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(l.Provider,{value:i},e.children)}}}]);